
#
#   StarScript Executer
#
#   0.0.1: Started on the 10th of October 2021 @ 2:06pm (ish)
#
#   0.0.7:    20-10-21 - 12:38pm until 3:03pm
#   0.0.7.1:  20-10-21 - 3:03pm until 4:41pm
#   0.0.7.2:  20-10-21 - 4:42pm until 5:59pm
#             20-10-21 - 8:54pm until 9:02pm
#             21-10-21 - 10:19am until 11:15am BECAUSE OF A FUCKING SCHOOL LOCKDOWN!!
#             21-10-21 - 1:23pm until 2:55pm
#             21-10-21 - 8:21pm until 9:00pm
#             22-10-21 - 10:20am until 11:20am
#             25-10-21 - 8:38am until 8:57am
#   0.0.7.3:  25-10-21 - 8:57am until 12:42pm
#   0.0.8:    25-10-21 - 12:42pm until 2:15pm
#             25-10-21 - 4:36pm until 6:00pm
#   0.0.8.1:  26-10-21 - 9:35am until 10:00am
#             27-10-21 - 9:30am until 12:56pm
#   0.0.9:    27-10-21 - 12:59pm until 1:15pm
#             27-10-21 - 2:42pm until 2:55pm
#             27-10-21 - 9:07pm until 10:11pm
#   0.0.9.1:  27-10-21 - 10:12pm until 10:36pm
#             28-10-21 - 10:26am until 11:20pm
#             28-10-21 - 1:58pm until 2:18pm
#   0.0.9.2:  28-10-21 - 2:18pm until 3:00pm
#             1-11-21  - 8:54am until 10:06am
#   0.0.9.3:  1-11-21  - 10:31am until 3:00pm
#   0.0.10:   1-11-21  - 5:16pm until 6:00pm
#             1-11-21  - 6:57pm until 8:27pm
#   0.0.10.1: 1-11-21  - 8:27pm until 10:19pm
#   0.0.10.2: 2-11-21  - 12:34pm until 1:15pm
#             2-11-21  - 7:56pm until 9:00pm
#             3-11-21  - 9:42am until 11:20am
#             3-11-21  - 12:40pm until 1:00pm
#   0.0.10.3: 3-11-21  - 1:04pm until 2:30pm
#             4-11-21  - 10:28am until 11:20am
#   0.0.10.4: 8-11-21  - 10:01am until 10:04am
#             17-11-21 - 11:33am until 11:45am
#   0.0.11:   18-11-21 - 4:38pm until 5:30pm
#   0.0.11.1: 20-11-21 - 5:30pm until 6:00pm
#             20-11-21 - 7:20pm until 8:30pm
#             22-11-21 - 9:19am until 3:00pm
#   0.0.12:   22-11-21 - 4:44pm until 6:16pm
#             23-11-21 - 11:35am until 12:00pm
#             23-11-21 - 3:00pm until 6:00pm
#   0.1.0: 08-02-22 - 05:25pm until 06:50pm
#   0.1.0: 08-02-22 - 08:52pm until 09:00pm
#                   - 09:51pm until 10:10pm
#   0.1.0: 09-02-22 - 04:21pm until 06:00pm
#                   - 11:23pm until 11:36pm
#          10-02-22 - 08:39am until 08:45am
#                   - 10:25am until 11:20am
#                   - 12:01pm until 01:05pm
#                   - 02:27pm until 03:00pm
#          11-02-22 - 08:31am until 11:20am
#   0.1.1: 11-02-22 - 04:15pm until 05:32pm
#                     08:00pm until 09:00pm
#          13-02-22 - 10:39am until 2:29pm
#   0.1.2: 13-02-22 - 2:29pm until 3:47pm
#                     4:43pm until 6:00pm
#          14-02-22 - 9:20pm until 11:18am
#                     11:56am until 1:05pm
#                     1:45pm until 2:01pm
#  0.1.2.1:14-02-22 - 2:02pm until 2:55pm
#  0.1.3:  15-02-22 - 8:31am until 10:10am. [Totally not getting distracted by Education perfect.
#                                              no but fr i went from like 169th best in the school
#                                               to the 20th best. haha <333]
#                     4:54pm until 6:00pm
#          16-02-22 - 11:57am until 1:05pm
#                     4:43pm until 5:30pm
#          17-02-22 - 8:52am until 11:20pm - wHY ARE FUNCTIONS SO HARD TO DO - currently #1 in school in education perf though
#                     12:05pm until 12:56pm
#          18-02-22 - 3:02pm until 4:00pm
#                     11:19pm until 12:00pm
#          20-02-22 - 11:53am until 12:32pm
# 0.1.4: 20-02-22
#           12:33pm until 4:09pm
#        21-02-22
#           12:02pm until 12:30pm
#        22-2-22
#           8:49am until 9:00am
# 0.1.4.1: 24-02-22
#   12:12pm until 1:00pm
#        25-2-22
#         9:32am until ???
# 0.1.4.2: 04-03-22 - 2:27pm until 3:32pm
#                     7:29am until ???
# 0.1.4.3 - Let's just wrap this up for the open beta.
#   - 3:30pm (26-03-22) until 5:14pm (26-03-22)
#   - 6:42pm until 6:50pm (26-03-22)
#   - 2:28pm (27-03-22) until 3:54pm
#   - 12:01pm (30-03-22) until ----


# 0.2.0
#   5:30pm until 6:00pm - 31-03-22
#   9:00am until 11:20am - 1-04-22
#   9:42pm until 2:41pm - 2-04-22 - Classes & Stuff! Coming along nicely :P
# 0.2.1
#   2:43pm until 6:00pm - 2-04-22 - a lot of progress wtf
#   2:13pm until 2:36pm - 4-04-22 - on a roadtrip uwu
# 0.2.3
#   3:22pm until 4:40pm - 9-04-22 - Gonna work on console interaction
#   a lot more time cause fml
# 0.2.4
#   4:48pm until 6:48pm - 13-04-22 - The fact that we're getting somewhere makes me cry of happiness.
#                                    So- A lot of the VERRYY basics have been done. We still needa work on:
#                                    - If/Else statements
#                                    - Try/Catch statements
#                                    - Loops
#                                    - Functions (Defining Them)
#                                    - Classes (Perfecting them however we're pretty much nearly done)
#                                    - More console interaction
#                               HOWEVER- In true- Nova fashion- I'm going to neglect all of them
#                                   Cause i've just found out there is a threading feature in python.
#
#                                   I will now add threading to StarScript bc it was totally wanted.
#   I've Moved a bunch of stuff from the main.py file to the new Changelog.json!
#   6:48pm until 7:11pm (13-04-22) - Returns are now working!!! the say command accepts return statements
#   7:40pm until 10:18pm (13-04-22) - MAJOR MAJOR MAJOR PROGRESS :P. Math & Variable Interaction!
#   9:00am until 12:30pm (14-04-22) - More math stuff and a bunch of wonderful stuff, gearing up for the RELEASE OF OPEN ALPHA (Such as an installation file)

# 0.2.5
#   3:39pm until 4:51pm

#from compile import *
# Run If Main

from cmath import cos, sin, tan
from mailbox import linesep
from Core import *
import Core
from RunLine import *
from ast import Dict, Global
from tempfile import TemporaryDirectory
from windowExtension import *
from copyreg import pickle
from datetime import datetime
from gettext import NullTranslations
import inspect
import threading
# import discord
from msilib.schema import Class
# from multiprocessing.dummy import current_process5
import os
from pydoc import classname, text
from statistics import variance
from textwrap import indent
import time
from tkinter.tix import Form, Tree
# import strappdi
import platform
import sys
import json
import tkinter
import pickle
import random
from tracemalloc import stop
from turtle import fillcolor, left, mode, pos, position, resizemode, screensize
from unicodedata import name

# Why The Recode?
#   The previous version was fairly good however the code was clunky and really hard to undersatnd after having any gap in development longer than a day.
#   Techniques used were really bad as well seeing as my knowledge of python was quite- screwed from when the project started to where it's at now.
#   Stuff like OtherData being a list and not a structure (For example)
#
#   This recode will have very easy-to-understand code and will utilise many of the new- amazing assistant features that have come out/i've been given access too
#   From the start of development to now.
#   SUCH AS~ The amazing Github Copilot system. literally so cool.
# 
#       With this i'll also be working on various different executers on the side- just to get this looking perfect.

# Threads & Stuff
Threads = []

GlobalTD = {
    "Test": "Hello!"
}

Modules = {
    "Main": {
        "Enabled": True
    },
    "WindowExtension": {
        "Enabled": True
    }
}

# TODO:
#   #- Flags in classes (Done)
#   #- Build a system to take a line with flags set up that references other classes. (DONEEE)
#   #    - This would use a bracket system to hold the class references (Not really however we have a wonderful alternative)

GoTicker = 0
def runLine(lineScript, tempObject, attachedVariables):
    global GoTicker # Super Useless. Just- Variables before Variables are good
    global GlobalVariables
    global Modules
    global Threads
    # print(tempObject)
    # lineScript = Line to run
    # tempObject = FormerOtherdata
    try:
        tempObject["LinesRan"] += 1
    except:
        pass

    # Manipulate Flags
    if lineScript.startswith("@") and not lineScript.startswith("@flag"):
        # @Input.set &math.add @Input, @Value;
        Operation = lineScript.split(".", 1)
        Operation[0] = Operation[0].replace("@", "", 1)
        Operation[1] = Operation[1].split(" ", 1)

        # Is Set?
        if Operation[1][0] == "set":
            Result = getBubble(Operation[1][1], attachedVariables)
            # input(Result)

            # Updates Flags
            GlobalVariables[Operation[0]] = Result
            attachedVariables[Operation[0]] = Result
            # input(GlobalVariables)
            # Update Flag (As Class)
            try:
                attachedVariables[attachedVariables["$Selection"]]["Flags"][Operation[0]] = Result
                pass
            except:
                pass
    # OS
    if lineScript.startswith("os"):
        if lineScript.startswith("os.readfilelines "):
            # return &os.readfilelines @Location, @Mode;
            Operand = lineScript.split(" ")[1]
            Operand = Operand.split(",")
            File = getBubble(Operand[0], attachedVariables)
            Mode = getBubble(Operand[1], attachedVariables)

            ReturnV = open(File.strip(), "r", encoding=Mode.strip()).readlines()
            print("ReturnV!!!!", ReturnV)
            Core.setVreturn(ReturnV)
            tempObject.update({"return": ReturnV})
    # Strraw
    if lineScript.startswith("strraw say "):
        openStrRaw(
            [
                lineScript.replace("strraw say ", "", 1)
            ]
        )
    if lineScript.startswith("strraw open "):
        # strraw open Changelog
        openStrRaw(open(lineScript.replace("strraw open ", "", 1) + ".strraw").readlines())
    # Math
    if lineScript.startswith("math"):
        # math.add <Bubble1>, <Bubble2>;
        # math.cos <Bubble1>;
        
        if lineScript.startswith("math.add "):
            # MathValues = Core.grabValues(lineScript.split(" ", 1)[1])
            Table = lineScript.split(" ", 1)[1]
            Table = Table.split(", ")
            try:MathValues = [Core.getBubble(Table[0], attachedVariables).strip(), Core.getBubble(Table[1], attachedVariables).strip()]
            except:MathValues = [Core.getBubble(Table[0], attachedVariables), Core.getBubble(Table[1], attachedVariables)]
            # print("MathValues", MathValues)
            # Set the Return Value
            ReturnV = int(MathValues[0]) + int(MathValues[1])

            # Return
            Core.betterPrint("Notice", "Returning:", ReturnV)
            Core.setVreturn(ReturnV)
            tempObject.update({"return": ReturnV})
        if lineScript.startswith("math.sub "):
            # MathValues = Core.grabValues(lineScript.split(" ", 1)[1])
            Table = lineScript.split(" ", 1)[1]
            Table = Table.split(", ")
            try:MathValues = [Core.getBubble(Table[0], attachedVariables).strip(), Core.getBubble(Table[1], attachedVariables).strip()]
            except:MathValues = [Core.getBubble(Table[0], attachedVariables), Core.getBubble(Table[1], attachedVariables)]
            # print("MathValues", MathValues)
            # Set the Return Value
            ReturnV = int(MathValues[0]) - int(MathValues[1])

            # Return
            Core.betterPrint("Notice", "Returning:", ReturnV)
            Core.setVreturn(ReturnV)
            tempObject.update({"return": ReturnV})
        if lineScript.startswith("math.div "):
            # MathValues = Core.grabValues(lineScript.split(" ", 1)[1])
            Table = lineScript.split(" ", 1)[1]
            Table = Table.split(", ")
            try:MathValues = [Core.getBubble(Table[0], attachedVariables).strip(), Core.getBubble(Table[1], attachedVariables).strip()]
            except:MathValues = [Core.getBubble(Table[0], attachedVariables), Core.getBubble(Table[1], attachedVariables)]
            # print("MathValues", MathValues)
            # Set the Return Value
            ReturnV = int(MathValues[0]) / int(MathValues[1])

            # Return
            Core.betterPrint("Notice", "Returning:", ReturnV)
            Core.setVreturn(ReturnV)
            tempObject.update({"return": ReturnV})
        if lineScript.startswith("math.mul "):
            # MathValues = Core.grabValues(lineScript.split(" ", 1)[1])
            Table = lineScript.split(" ", 1)[1]
            Table = Table.split(", ")
            try:MathValues = [Core.getBubble(Table[0], attachedVariables).strip(), Core.getBubble(Table[1], attachedVariables).strip()]
            except:MathValues = [Core.getBubble(Table[0], attachedVariables), Core.getBubble(Table[1], attachedVariables)]
            # print("MathValues", MathValues)
            # Set the Return Value
            ReturnV = int(MathValues[0]) * int(MathValues[1])

            # Return
            Core.betterPrint("Notice", "Returning:", ReturnV)
            Core.setVreturn(ReturnV)
            tempObject.update({"return": ReturnV})
        if lineScript.startswith("math.cos "):
            # MathValues = Core.grabValues(lineScript.split(" ", 1)[1])
            Table = lineScript.split(" ", 1)[1]
            Table = Table.split(", ")
            try:MathValues = [Core.getBubble(Table[0], attachedVariables).strip()]
            except:MathValues = [Core.getBubble(Table[0], attachedVariables)]
            # print("MathValues", MathValues)
            # Set the Return Value
            ReturnV = cos(MathValues[0])

            # Return
            Core.betterPrint("Notice", "Returning:", ReturnV)
            Core.setVreturn(ReturnV)
            tempObject.update({"return": ReturnV})
        if lineScript.startswith("math.tan "):
            # MathValues = Core.grabValues(lineScript.split(" ", 1)[1])
            Table = lineScript.split(" ", 1)[1]
            Table = Table.split(", ")
            try:MathValues = [Core.getBubble(Table[0], attachedVariables).strip()]
            except:MathValues = [Core.getBubble(Table[0], attachedVariables)]
            # print("MathValues", MathValues)
            # Set the Return Value
            ReturnV = tan(MathValues[0])

            # Return
            Core.betterPrint("Notice", "Returning:", ReturnV)
            Core.setVreturn(ReturnV)
            tempObject.update({"return": ReturnV})
        if lineScript.startswith("math.sin "):
            # MathValues = Core.grabValues(lineScript.split(" ", 1)[1])
            Table = lineScript.split(" ", 1)[1]
            Table = Table.split(", ")
            try:MathValues = [Core.getBubble(Table[0], attachedVariables).strip()]
            except:MathValues = [Core.getBubble(Table[0], attachedVariables)]
            # print("MathValues", MathValues)
            # Set the Return Value
            ReturnV = sin(MathValues[0])

            # Return
            Core.betterPrint("Notice", "Returning:", ReturnV)
            Core.setVreturn(ReturnV)
            tempObject.update({"return": ReturnV})
    if lineScript == "thread<wait>":
        for t in Threads:
            t.join()
    if lineScript.startswith("import "):
        modeLine = lineScript.split(" ")
        # First try to import with the modules folder
        try:
            runScript(open(f"{StarSettings['Install']}\\Modules\\{modeLine[1]}.str", "r").read(), tempObject, attachedVariables)
        # Try to import from a file local to the python file
        except:
            runScript(open(f"{os.getcwd()}\\{modeLine[1]}.str", "r").read(), tempObject, attachedVariables)
    # Delay Script for x amount of time
    if lineScript.startswith("delay "):
        # Grab the delay time
        delayTime = lineScript.split(" ", 1)[1]
        # Convert to int
        delayTime = int(delayTime)
        # Delay the script
        time.sleep(delayTime)
    # Construct Variable
    if lineScript.startswith("var "):
        # var TestVariable string Input: TestVariable1, Second: TestVariable2
        aboutToAdd = {
            f"Configuartion_{random.randint(100,999)}": f"{random.randint(1000,9999)} - This Makes Sure everything is Working"
        }
        lineWork = lineScript.split(" ", 3)
        GlobalVariables.update({
            f"{lineWork[1]}": {
                "Type": f"{lineWork[2]}",
                "Flags": {}
            }
        })
        GlobalVariables[f"{lineWork[1]}"]["Flags"].update(GlobalClasses[lineWork[2]]["TagsToFill"]) # Default
        ReturnV = grabValues(lineWork[3])
        GlobalVariables[f"{lineWork[1]}"]["Flags"].update(ReturnV) # Extras
        betterPrint("Notice","Current Variables Mode:", GlobalVariables)
        # Append Current Variable Directory
        attachedVariables.update(GlobalVariables)
        # Run Main Function
        betterPrint("Notice", "About to run the (Main) script of a class that has just been defined using var")
        print("ABOUT TO RUN:", GlobalClasses[lineWork[2]]["Main"])
        runScript(GlobalClasses[lineWork[2]]["Main"], tempObject, attachedVariables)
        betterPrint("Success", "Running the script should've been successful :)")
    # Returns
    if lineScript.startswith("return "):
      try:
        MotorTemp = tempObject
        # input(MotorTemp)
        # input("whhhh")
        # return TestVariable1, Second: TestVariable2
        # ReturnV = grabValues(lineScript.split(" ", 1)[1])
        # print(ReturnV)
        ReturnV = Core.getBubble(lineScript.split(" ", 1)[1], attachedVariables)
        # input(f"wait for it: {ReturnV}")
        Core.betterPrint("Notice", "Returning:", ReturnV)
        tempObject.update({"return": ReturnV})
        print("RETURNED:", tempObject)
        # tempObject = {"return": "blank"}
        # input(tempObject)
        # input(tempObject)
        # try:
            # if tempObject["SpecialFlag"] == "SentFromCore":

            # We're gonna dangerously assume that a direct-return means the script is DEFINITELY ran from a module.
            # This'll backfire later but whatever.
        print(__name__)
        Core.setVreturn(tempObject["return"])
        if not __name__ == "__main__":
                # input("-----")
                return tempObject["return"]
        else:
                return tempObject, attachedVariables
      except:
          input("Error: Fatal error with the return statement")
    # Direct System Calls
    if lineScript.startswith("say "):
        SplitDrive = lineScript.split(" ", 1)[1]

        Response = getBubble(SplitDrive, attachedVariables)
        print(f"{AnnounceOutputs}{Response}")
        # # print(f"{AnnounceOutputs}Direct Paste of Variable:{attachedVariables[SplitDrive]}")
        # if lineScript.split(" ", 1)[1].startswith("@"):
        #     SplitDrive = SplitDrive.replace("@", "", 1)
        #     print(f"{AnnounceOutputs}say (Variable):{attachedVariables[SplitDrive]}")
        # else:
        #     print(f"{AnnounceOutputs}say      (Raw): {SplitDrive}")
    # Running Programs
    if lineScript.startswith("run"):
        # run C:\Users\Andi\Documents\desktop\starScript-0.2.3\Scripts\FeatureTest
        # run Scripts/PerformanceTest
        runScript(open(f"{lineScript.split(' ')[1]}.str", "r").readlines(), tempObject, GlobalVariables)
    # Raising Issues
    if lineScript.startswith("raise"):
        if lineScript == "raise classes":
            print("honestly this being a command is a sign of a stupid coding language")
            print("but whatever- our developer is an idiot. \nClasses:")
            print(json.dumps(GlobalClasses, indent=4))
        if lineScript.startswith("raise error"):
            if lineScript == "raise error":
                # No reason given
                bprint("Error", f"There has been an unspecified error!")
            else:
                raiseTemp = lineScript.split(": ", 1)[1]
                bprint("Error", f"{raiseTemp}")
        if lineScript.startswith("raise warning"):
            if lineScript == "raise warning":
                # No reason given
                print(f"{Warning}There has been an unspecified warning!")
            else:
                raiseTemp = lineScript.split(": ", 1)[1]
                print(f"{Warning}{raiseTemp}")
        if lineScript.startswith("raise notice"):
            if lineScript == "raise notice":
                # No reason given
                print(f"{Notice}There has been an unspecified notice!")
            else:
                raiseTemp = lineScript.split(": ", 1)[1]
                print(f"{Notice}{raiseTemp}")
        if lineScript.startswith("raise success"):
            if lineScript == "raise success":
                # No reason given
                print(f"{Success}There has been an unspecified success!")
            else:
                raiseTemp = lineScript.split(": ", 1)[1]
                print(f"{Success}{raiseTemp}")
        if lineScript.startswith("raise comment"):
            if lineScript == "raise comment":
                # No reason given
                print(f"{Comment}There has been an undefined comment!")
            else:
                raiseTemp = lineScript.split(": ", 1)[1]
                print(f"{Comment}{raiseTemp}")
        if lineScript.startswith("raise debug"):
            if lineScript == "raise debug":
                # No reason given
                print(f"{Debug}There has been an unspecified debug!")
            else:
                raiseTemp = lineScript.split(": ", 1)[1]
                print(f"{Debug}{raiseTemp}")
    if lineScript.startswith("print "):
        # Print requires 2 flags
        # 'value' & 'repeat'
        # if StarSettings["alerts"]["Error"] == True:
        bprint("Error", "The print function failed to execute~")
        bprint("Debug", f"Heya! strlng5(2ndEdition) no longer uses the print function. print <Variable Mention>/<Bubble> is a very old command and doesn't work especially since bubbles aren't a thing in this language anymore. Please use `say`. To print raw text: say <Text>. To print a flag/DirectFlagVariable: say @<Variable>")

    # Try Running Line from another File
    if Modules["WindowExtension"]["Enabled"] == True: windowExtensionRunLine(lineScript, tempObject, attachedVariables)

    return tempObject, attachedVariables


def runScript(script, tempObject, attachedVariables):
    global GlobalClasses
    global Threads
    # script = script.replace("^*^", "\n")
    tempPointer = 0
    # print(script)
    scriptLength = len(script)

    # Comment Stuff
    previousMode = ""
    # Class Stuff
    holdingCell = []
    lineMode = "Execute"
    otherMode = "None"
    nameMode = "??"
    className = "What"
    classTicker = 0
    holdingClass = {}

    # RUN
    while tempPointer < scriptLength:
        aboutToRun = script[tempPointer].split("^*^")
        tick = 0
        while tick < len(aboutToRun):
            aboutToRun[tick] = aboutToRun[tick].strip()
            if lineMode == "Comment":
                if StarSettings["alerts"]["Comment"] == True:
                    print(f"{Comment}{aboutToRun[tick]}")
                if "-/" in aboutToRun[tick]:
                    line = aboutToRun[tick].split("-/")[1]
                    aboutToRun[tick] = line
                    lineMode = previousMode
            if lineMode == "Execute":
                if aboutToRun[tick].startswith("--"):
                    if StarSettings["alerts"]["Comment"] == True:
                        print(f"{Comment}{aboutToRun[tick]}")
                elif aboutToRun[tick].startswith("/-"):
                    previousMode = str(lineMode)
                    lineMode = "Comment"
                elif aboutToRun[tick].startswith("class"):
                    holdingCell = []
                    otherMode = "None" # Current Class-Working Mode
                    className = aboutToRun[tick].split(" ")[1]
                    holdingClass = {
                        "TagsToFill": {
                            "ExampleVariablePleaseNeverFillMe": "None"
                        },
                        "Main": [
                            "// Main Class",
                            "raise notice: This Class has been Initialised Correctly!"
                        ]
                    }
                    lineMode = "Class"
                    classTicker = 0 # Should be a value of 1 however it gets set to one in the linemode = class
                else:
                    # See if line is a variable {Class}?
                    # print("ATOTHEV", attachedVariables)

                    # Check/Prepare as Thread
                    if aboutToRun[tick].startswith("thread<+>"):
                        ThreadMode = True
                        aboutToRun[tick] = aboutToRun[tick].replace("thread<+>", "", 1)
                    else:
                        ThreadMode = False

                    if aboutToRun[tick].split(".")[0] in attachedVariables:
                        # Main.value
                        # Main.add Value: 2;
                        TempLine = aboutToRun[tick].split(".")
                        TempLine[1] = TempLine[1].split(" ", 1)
                        # Get Class Type
                        ClassType = attachedVariables[TempLine[0]]["Type"]
                        # Set up all the variables:
                        try:addedVariables = grabValues(TempLine[1][1])
                        except:addedVariables = {}
                        # Run it as a script
                        try: oldSelection = attachedVariables["$Selection"] 
                        except: oldSelection = "None"
                        attachedVariables.update({"$Selection": f"{aboutToRun[tick].split('.')[0]}"})
                        handOffVariable = attachedVariables
                        handOffVariable.update(attachedVariables[TempLine[0]]["Flags"])
                        handOffVariable.update(addedVariables)
                        # input(handOffVariable)
                        # attachment = {}.update(attachedVariables[TempLine[0]]["Flags"].update(addedVariables))
                        if ThreadMode == True:
                            # Run As Thread
                            Threads.append(threading.Thread(target=runScript, args=(GlobalClasses[ClassType][TempLine[1][0]], tempObject, handOffVariable)))
                            Threads[-1].start()
                        else:
                            runScript(GlobalClasses[ClassType][TempLine[1][0]], tempObject, handOffVariable)#.update(addedVariables))
                    # See if the line is a class (Undefined Class)
                    if aboutToRun[tick].split(".")[0] in GlobalClasses:
                        # This means it's possible to run as a class!
                        TempLine = aboutToRun[tick].split(".")
                        TempLine[1] = TempLine[1].split(" ", 1)
                        print(TempLine[0], TempLine[1][0])
                        # Set up all the variables:
                        addedVariables = grabValues(TempLine[1][1])
                        # Run it as a script
                        handOffVariable = attachedVariables
                        handOffVariable.update(addedVariables)
                        print(handOffVariable)
                        if ThreadMode == True:
                            Threads.append(threading.Thread(target=runScript, args=(GlobalClasses[TempLine[0]][TempLine[1][0]], tempObject, handOffVariable)))
                            Threads[-1].start()
                        else:
                            runScript(GlobalClasses[TempLine[0]][TempLine[1][0]], tempObject, handOffVariable)
                        pass
                        # Run As Thread or
                    if ThreadMode == True:
                        # aboutToRun[tick] = aboutToRun[tick][8:]
                        Threads.append(threading.Thread(target=runLine, args=(aboutToRun[tick], tempObject, attachedVariables)))
                        Threads[-1].start()
                        # return tempObject, attachedVariables
                    else:
                        # Run as Line
                        tempObject, attachedVariables = runLine((aboutToRun[tick].replace("\n", "")).replace("\\n", "\n"), tempObject, attachedVariables)
            if lineMode == "Class":
                # Construct a class object to send directly to the makeClass function
                if "{" in aboutToRun[tick]:
                    classTicker += 1
                if "}" in aboutToRun[tick]:
                    classTicker -= 1
                if classTicker == 1:
                    otherMode = "*AboutToGoNone*"
                
                # Function Initialisation
                if aboutToRun[tick].startswith("func"):
                    nameMode = aboutToRun[tick].split(" ")[1]
                    otherMode = "AboutToFunction"
                    holdingClass.update({str(nameMode): [
                        f"// {nameMode} function."
                    ]})
                if otherMode == "None":
                    holdingClass["Main"].append(aboutToRun[tick])
                    betterPrint("Notice", "Current Holding Class", holdingClass)
                if otherMode == "Function":
                    holdingClass[nameMode].append(aboutToRun[tick])
                
                if aboutToRun[tick].startswith("@flag "):
                    temp = aboutToRun[tick].split(" ")[1].replace(":", "")
                    Ven = "None" # Default Value
                    if "=" in temp:
                        # A default value has been detected;
                        Ven = temp.split(" = ", 1)[1] # The Default Value

                    holdingClass["TagsToFill"].update({
                        str(temp): Ven
                    })
                

                # This Means the Class has been closed.
                if classTicker == 0:
                    lineMode = "Execute"
                    betterPrint("Warning", "Final Holding Class", holdingClass)
                    GlobalClasses.update({str(className): holdingClass})
                    betterPrint("Warning", "Current Global Class", GlobalClasses)
                    # print(str(json.loads(GlobalClasses)))
                    print(GlobalClasses)
                
                # This is so "}" isn't put anywhere
                if otherMode == "AboutToFunction":
                    otherMode = "Function"
                if otherMode == "*AboutToGoNone*":
                    otherMode = "None"
                # holdingClass.append(aboutToRun[tick]) # formerly holding cell
            tick += 1
        tempPointer += 1
    return tempObject

# GlobalVariables = {
#     "ExampleTextVariable": "I hold an example value :P",
#     "ExampleNumberVariable": 1,
#     "ExampleClassDefVariable": "string.value Input: DefVariable",
#     "ExampleClassVariable": {
#         "Type": "string",
#         "Flags": {
#             "Input": "Defined Class"
#         }
#     }
# }

# GlobalTD = runScript(open(f"{os.getcwd()}\\Scripts\\FeatureTest.str", "r").readlines(), GlobalTD, GlobalVariables)

# Script Completed.
# if StarSettings["runCommandLineWhenDone"] == True:
if __name__ == "__main__":
  while True:
    Command = input(f"{Console}Command:")
    betterPrint("Timing", "Started Tracking Command: -[", Command, "]-")
    start_time = time.perf_counter()


    runScript([Command], {
        "LinesRan": 0
    }, GlobalVariables)


    end_time = time.perf_counter()
    # print(end_time)
    betterPrint("Timing", f'It took {end_time - start_time: 0.2f} second(s) to complete.')